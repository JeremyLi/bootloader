/*
 * Memory Spaces Definitions.
 *
 * Need modifying for a specific board. 
 *   FLASH.ORIGIN: starting address of flash
 *   FLASH.LENGTH: length of flash
 *   RAM.ORIGIN: starting address of RAM bank 0
 *   RAM.LENGTH: length of RAM bank 0
 *
 * The values below can be addressed in further linker scripts
 * using functions like 'ORIGIN(RAM)' or 'LENGTH(RAM)'.
 */

MEMORY
{
  RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 128K
  CCMRAM (xrw) : ORIGIN = 0x10000000, LENGTH = 64K
  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 1024K
  FLASHB1 (rx) : ORIGIN = 0x00000000, LENGTH = 0
  EXTMEMB0 (rx) : ORIGIN = 0x00000000, LENGTH = 0
  EXTMEMB1 (rx) : ORIGIN = 0x00000000, LENGTH = 0
  EXTMEMB2 (rx) : ORIGIN = 0x00000000, LENGTH = 0
  EXTMEMB3 (rx) : ORIGIN = 0x00000000, LENGTH = 0
  MEMORY_ARRAY (xrw)  : ORIGIN = 0x20002000, LENGTH = 32
}

/*
 * For external ram use something like:

   RAM (xrw) : ORIGIN = 0x64000000, LENGTH = 2048K

 */

/*
 * Default linker script for Cortex-M (it includes specifics for STM32F[34]xx).
 * 
 * To make use of the multi-region initialisations, define
 * OS_INCLUDE_STARTUP_INIT_MULTIPLE_RAM_SECTIONS for the _startup.c file.
 */
/* OUTPUT_FORMAT("elf32littlearm","elf32littlearm","elf32littlearm") */
OUTPUT_ARCH(arm)
ENTRY(Reset_Handler)

/*
 * The '__stack' definition is required by crt0, do not remove it.
 */
__stack = ORIGIN(RAM) + LENGTH(RAM);

_estack = __stack - 0x010000; 	/* STM specific definition */

/*
 * Default stack sizes.
 * These are used by the startup in order to allocate stacks 
 * for the different modes.
 */

/* __Main_Stack_Size = 1024 ;

//PROVIDE ( _Main_Stack_Size = __Main_Stack_Size ) ;

//__Main_Stack_Limit = __stack  - __Main_Stack_Size ;

*/


/* "PROVIDE" allows to easily override these values from an 
 * object file or the command line. */
 /*
//PROVIDE ( _Main_Stack_Limit = __Main_Stack_Limit ) ;
*/
/*
 * There will be a link error if there is not this amount of 
 * RAM free at the end. 
 */

 /* */
_Minimum_Stack_Size = 256 ;

/*
 * Default heap definitions.
 * The heap start immediately after the last statically allocated 
 * .sbss/.noinit section, and extends up to the main stack limit.
 */

 /*
//PROVIDE ( _Heap_Begin = _end_noinit ) ;
//PROVIDE ( _Heap_Limit = __stack - __Main_Stack_Size ) ;
*/
/* 
 * The entry point is informative, for debuggers and simulators,
 * since the Cortex-M vector points to it anyway.
 */

 /*
//ENTRY(_start)
*/

/* Sections Definitions */

SECTIONS
{
	. = 0x08000000;
    . = ALIGN(4);
    /*
     * For Cortex-M devices, the beginning of the startup code is stored in
     * the .isr_vector section, which goes to FLASH. 
     */
    .isr_vector :
    {
        FILL(0xFF)
        __vectors_start = ABSOLUTE(.) ;
        __vectors_start__ = ABSOLUTE(.) ; /* STM specific definition */
        KEEP(*(.isr_vector))     	/* Interrupt vectors */
        
		KEEP(*(.cfmconfig))			/* Freescale configuration words */   
		     
        /* 
         * This section is here for convenience, to store the
         * startup code at the beginning of the flash area, hoping that
         * this will increase the readability of the listing.
         */
        *(.after_vectors .after_vectors.*)	/* Startup code and ISR */
		__vectors_end = ABSOLUTE(.) ;
        __vectors_end__ = ABSOLUTE(.) ; /* STM specific definition */
    } > FLASH

    /*
     * The program code is stored in the .text section, 
     * which goes to FLASH.
     */
     . = ALIGN(4);
    .text :  
    {
    	__text_start__ = .;
        *(.text .text.*)			/* all remaining code */
 
 		/* read-only data (constants) */
        *(.rodata .rodata.* .constdata .constdata.*) 		

        /* *(vtable)					/* C++ virtual tables */

		KEEP(*(.eh_frame*))

		/*
		 * Stub sections generated by the linker, to glue together 
		 * ARM and Thumb code. .glue_7 is used for ARM code calling 
		 * Thumb code, and .glue_7t is used for Thumb code calling 
		 * ARM code. Apparently always generated by the linker, for some
		 * architectures, so better leave them here.
		 */
        *(.glue_7)
        *(.glue_7t)

    }> FLASH
    
 
        
	/* ARM magic sections */
	.ARM.extab :  
   	{
       *(.ARM.extab* .gnu.linkonce.armextab.*)
   	}> FLASH
   	
   	. = ALIGN(4);
   	__exidx_start = .;   	
   	.ARM.exidx :   
   	{
       *(.ARM.exidx* .gnu.linkonce.armexidx.*)
   	}> FLASH
   	__exidx_end = .;
   	

    _etext = .;
    __etext = .;
 
 	. = ALIGN(4);
    /*
     * For some STRx devices, the beginning of the startup code
     * is stored in the .flashtext section, which goes to FLASH.
     */
    .flashtext : 
    {
        *(.flashtext .flashtext.*)	/* Startup code */
    }> FLASH
        
    . = ALIGN(4);
    .index :
    {
    	__data_array_start = .;
        
        LONG(ADDR(.data));
        LONG(LOADADDR(.data));
        LONG(SIZEOF(.data));
        
        __data_array_end = .;
        
        __bss_array_start = .;
        
        LONG(ADDR(.bss));
        LONG(SIZEOF(.bss));
        
        __bss_array_end = .;
        __bootloader_end = .;
        LONG(LOADADDR(.bss)+SIZEOF(.bss));
    } >FLASH
    
       . = ALIGN(4);
    	
    	__data_lma = .;
    /*
     * The initialised data section.
     *
     * The program executes knowing that the data is in the RAM
     * but the loader puts the initial values in the FLASH (inidata).
     * It is one task of the startup to copy the initial values from 
     * FLASH to RAM.
     */
     . = 0x20010200;
     _sidata = .;
    .data _sidata :
    {
         . = ALIGN(4);
    	FILL(0xFF)
        /* This is used by the startup code to initialise the .data section */
        _sdata = . ;        	/* STM specific definition */
        __data_start__ = . ;
		*(.data_begin .data_begin.*)

		*(.data .data.*)
		
		*(.data_end .data_end.*)
	    . = ALIGN(4);

	    /* This is used by the startup code to initialise the .data section */
        _edata = . ;        	/* STM specific definition */
        __data_end__ = . ;
    } > RAM AT>FLASH
   	. = ALIGN(4);
    __bss_start__ = .;
    __bss_start = . ;     	/* standard newlib definition */
    /* The primary uninitialised data section. */
    .bss (NOLOAD):
    {    
        _sbss = .;              /* STM specific definition */
        *(.bss_begin .bss_begin.*)

        *(.bss .bss.*)
        *(COMMON)
        
        *(.bss_end .bss_end.*)
	    _ebss = . ;             /* STM specific definition */
    } > RAM
     . = ALIGN(4);
     __bss_end = .;        /* standard newlib definition */
    __bss_end__ = .;
    __end__ = .;
    end = .;
    /* Remove information from the standard libraries */
    /DISCARD/ :
    {
        libc.a ( * )
        libm.a ( * )
        libgcc.a ( * )
    }
}
